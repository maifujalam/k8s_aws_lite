pipeline {
    agent {
        kubernetes {
            yaml '''
            apiVersion: v1
            kind: Pod
            metadata:
              labels:
                jenkins/jenkins-jenkins-agent: "true"
                jenkins/label: "jenkins-jenkins-agent"
              namespace: jenkins
            spec:
              containers:
              - name: jnlp
                image: docker.io/skmaifujalam/jenkins-agent:5
                imagePullPolicy: IfNotPresent
                env:
                - name: JENKINS_TUNNEL
                  value: jenkins-agent.jenkins.svc.cluster.local:50000
                - name: REMOTING_OPTS
                  value: -noReconnectAfter 1d
                - name: JENKINS_AGENT_WORKDIR
                  value: /home/jenkins/agent
                - name: JENKINS_URL
                  value: http://jenkins.jenkins.svc.cluster.local:8080/
                resources:
                  limits:
                    memory: 512Mi
                    cpu: 500m
                  requests:
                    memory: 256Mi
                    cpu: 250m
                volumeMounts:
                - name: workspace-volume
                  mountPath: /home/jenkins/agent
              volumes:
              - name: workspace-volume
                emptyDir: {}
              restartPolicy: Never
              serviceAccountName: default
            '''
        }
    }

    environment {
        BUILD_NUMBER = sh(
                       script: 'echo "$(date +%Y%m%d%H%M)_$(git rev-parse --short HEAD)"',
                       returnStdout: true).trim()
        HELM_REPO_NAME="public-helm-repository"
    }

    parameters {
        string(name: 'GIT_REPO_NAME', defaultValue: 'https://github.com/maifujalam/k8s_aws_lite.git', description: 'Git repo URL')
        string(name: 'GIT_BRANCH_NAME', defaultValue: 'main', description: 'Branch to work with')
        string(name: 'APP_FOLDER_PATH', defaultValue: 'k8s/v1.32.2/manifests/hello-kubernetes', description: 'App folder path')
        string(name: 'HELM_REPO', defaultValue: 's3://public-helm-repository-20231023095000508500000001', description: 'Enter the helm remote name,where to push')
    }

    stages {
        stage('üîß Update Application') {
            steps {
                script {
                    dir("${params.APP_FOLDER_PATH}") {
                        echo "üìÇ Application Folder: ${params.APP_FOLDER_PATH}"

                        def chartFile = sh(
                            script: 'test -f Chart.yaml && echo Chart.yaml || (test -f Chart.yml && echo Chart.yml)',
                            returnStdout: true
                        ).trim()

                        if (!chartFile) {
                            error("‚ùå No Chart.yaml or Chart.yml found in workspace")
                        }

                        echo "üìÑ Using chart file: ${chartFile}"
                        env.APP_NAME    = sh(script: "yq eval -r '.name' ${chartFile}", returnStdout: true).trim()
                        env.APP_VERSION = sh(script: "yq eval -r '.version' ${chartFile}", returnStdout: true).trim()
                        env.TARGET_VERSION = "${env.APP_VERSION}-${env.BUILD_NUMBER}"

                        if (!env.APP_NAME || !env.APP_VERSION) {
                            error "‚ùå Chart file missing 'name' or 'version'"
                        }

                        echo "‚ÑπÔ∏è App Name: ${env.APP_NAME}"
                        echo "‚ÑπÔ∏è App Version: ${env.APP_VERSION}"
                        echo "‚ÑπÔ∏è Build Number: ${env.BUILD_NUMBER}"
                        echo "‚ÑπÔ∏è Target Version: ${env.TARGET_VERSION}"

                        echo "Updating the Deployment file"

                        def deploymentFile = sh(
                            script: "test -f ${env.APP_NAME}-app.yaml && echo ${env.APP_NAME}-app.yaml",
                            returnStdout: true
                        ).trim()

                        if (!deploymentFile) {
                            error("‚ùå No ${env.APP_NAME}-app.yaml found in workspace")
                        }
                        def cat_deployment_file=sh(script: "cat ${deploymentFile}", returnStdout: true).trim()
//                         echo "Deployment File Before Update:- ${cat_deployment_file}"
                        try {
                            sh(
                                script: "yq -i '.spec.source.targetRevision = \"${env.TARGET_VERSION}\"' ${deploymentFile}",
                                returnStdout: true
                            ).trim()
                            echo "‚úÖ Deployment file updated: ${deploymentFile}"
//                             def updatedContent = sh(
//                             script: "cat ${deploymentFile}",
//                             returnStdout: true).trim()
//                             echo "üìÑ yq output: ${updatedContent}"
                        } catch (Exception e) {
                            error("üö´ Version upgrade error: ${e.message}")
                        }
                    }
                }
            }
        }

        stage('Package üì¶ Helm Chart') {
            when { expression { currentBuild.result == null || currentBuild.result == 'SUCCESS' } }
            steps {
                script {
                    dir("${params.APP_FOLDER_PATH}") {
                        try {
                            def template_output = sh(script: 'helm template . -f values.*.yaml', returnStdout: true).trim()
                            echo "Helm template output:\n${template_output}"
                            echo "\n\n ‚úÖ Helm template validation passed.\n"
                        } catch (Exception e) {
                            error("‚ùå Helm template validation failed: ${e}")
                        }
                        try {
                            // Run helm template command
                            def lint_output = sh(script: 'helm lint . ', returnStdout: true).trim()
                            echo "Helm lint output:\n${lint_output}"
                            echo "\n\n ‚úÖ Helm lint successful.\n"
                        } catch (Exception e) {
                            error("‚ùå  Helm lint failed: ${e}")
                        }
                        echo "üì¶ Packaging Helm Chart"
                        echo "‚ÑπÔ∏è  App: ${env.APP_NAME} | Target Version: ${env.TARGET_VERSION}"
                        try {
                            // Run helm template command
                            def package_output = sh(script: 'helm package . ', returnStdout: true).trim()
                            echo "Helm package output:\n${package_output}"
                            echo "Updating Target Version"
                            def LATEST_HELM_CHART=sh(script: "ls -t *.tgz | head -n 1",returnStdout: true).trim()
                            sh "mv ${LATEST_HELM_CHART} ${env.APP_NAME}_${env.TARGET_VERSION}.tgz"
                            echo "\n\nHelm package successful.\n"
                        } catch (Exception e) {
                            error("Helm package failed: ${e}")
                        }
                    }
                }
            }
        }

        stage('üéØ Push Helm Chart') {
            when { expression { currentBuild.result == null || currentBuild.result == 'SUCCESS' } }
            steps {
                script {
                    echo "üì§ Pushing Helm Chart"
                    dir("${params.APP_FOLDER_PATH}") {
                        def LATEST_HELM_CHART=sh(script: "ls -t *.tgz | head -n 1",returnStdout: true).trim()
                        echo "Latest helm chart build: ${env.TARGET_VERSION}"
                        withCredentials([
                            string(credentialsId: 'S3_WRITE_AWS_ACCESS_KEY_ID', variable: 'AWS_ACCESS_KEY_ID'),
                            string(credentialsId: 'S3_WRITE_AWS_SECRET_ACCESS_KEY', variable: 'AWS_SECRET_ACCESS_KEY')
                        ]) {
                            def INIT_HELM_REPO=sh(script: "helm plugin install https://github.com/hypnoglow/helm-s3.git --version 0.16.2;helm plugin ls;helm repo add ${HELM_REPO_NAME} ${params.HELM_REPO};helm repo update;helm s3 reindex public-helm-repository;",returnStdout: true).trim()
                            echo "Latest helm initialize: ${INIT_HELM_REPO}"
                            def HELM_PUSH_REPO=sh(script: "helm s3 push --force ${LATEST_HELM_CHART} ${HELM_REPO_NAME};",returnStdout: true).trim()
                            echo "‚úÖ Push Helm Chart: ${HELM_PUSH_REPO} Successful"
                            if (fileExists("${LATEST_HELM_CHART}")) {
                                echo "üßπ Removing local Helm chart: ${LATEST_HELM_CHART}"
                                sh "rm -vf ${LATEST_HELM_CHART}"
                            } else {
                                echo "‚ö†Ô∏è Helm chart not found: ${LATEST_HELM_CHART}"
                            }
                        }
                    }
                }
            }
        }

        stage('üì§ Push Changes to Git') {
            when { expression { currentBuild.result == null || currentBuild.result == 'SUCCESS' } }
            steps {
                withCredentials([usernamePassword(credentialsId: "GIT_CRED", usernameVariable: 'GIT_USER', passwordVariable: 'GIT_TOKEN')]) {
                    script {
                        sh """
                            git config user.email "sk.maifujalam@gmail.com"
                            git config user.name "${GIT_USER}"

                            git checkout ${params.GIT_BRANCH_NAME}

                            git add .

                            if ! git diff --cached --quiet; then
                              git commit -m "Edited with Jenkins pipeline: Build ${env.BUILD_NUMBER}"
                              git push https://${GIT_USER}:${GIT_TOKEN}@github.com/maifujalam/k8s_aws_lite.git ${params.GIT_BRANCH_NAME}
                            else
                              echo "‚úÖ No changes to commit"
                            fi
                        """
                    }
                }
            }
        }

        stage('Deploy üöÄ Argocd Application') {
            when { expression { currentBuild.result == null || currentBuild.result == 'SUCCESS' } }
            steps {
                script {
                    echo "üöÄ Deploying ArgoCD App"
                    which kubectl
                    sh "kubectl apply -f *-app.yaml"
                    echo "‚úÖ App Deployed. Sync in Argo CD if needed."
                }
            }
        }
    }

    post {
        always {
            echo "üèÅ Pipeline finished."
        }
        failure {
            echo "‚ùå Pipeline failed."
        }
        success {
            echo "‚úÖ Helm chart build & deployment successful."
        }
    }
}
