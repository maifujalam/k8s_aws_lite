pipeline {
    agent {
        kubernetes {
            yaml '''
            apiVersion: v1
            kind: Pod
            metadata:
              labels:
                jenkins/jenkins-jenkins-agent: "true"
                jenkins/label: "jenkins-jenkins-agent"
              namespace: jenkins
            spec:
              containers:
              - name: jnlp
                image: docker.io/skmaifujalam/jenkins-agent:5
                imagePullPolicy: IfNotPresent
                env:
                - name: JENKINS_TUNNEL
                  value: jenkins-agent.jenkins.svc.cluster.local:50000
                - name: REMOTING_OPTS
                  value: -noReconnectAfter 1d
                - name: JENKINS_AGENT_WORKDIR
                  value: /home/jenkins/agent
                - name: JENKINS_URL
                  value: http://jenkins.jenkins.svc.cluster.local:8080/
                resources:
                  limits:
                    memory: 512Mi
                    cpu: 500m
                  requests:
                    memory: 256Mi
                    cpu: 250m
                volumeMounts:
                - name: workspace-volume
                  mountPath: /home/jenkins/agent
              volumes:
              - name: workspace-volume
                emptyDir: {}
              restartPolicy: Never
              serviceAccountName: default
            '''
        }
    }

    environment {
        BUILD_NUMBER = sh(
                       script: 'echo "$(date +%Y%m%d%H%M)_$(git rev-parse --short HEAD)"',
                       returnStdout: true).trim()
    }

    parameters {
        string(name: 'GIT_REPO_NAME', defaultValue: 'https://github.com/maifujalam/k8s_aws_lite.git', description: 'Git repo URL')
        string(name: 'GIT_BRANCH_NAME', defaultValue: 'main', description: 'Branch to work with')
        string(name: 'APP_FOLDER_PATH', defaultValue: 'k8s/v1.32.2/manifests/hello-kubernetes', description: 'App folder path')
    }

    stages {
        stage('üîß Update Application') {
            steps {
                script {
                    dir("${params.APP_FOLDER_PATH}") {
                        echo "üìÇ Application Folder: ${params.APP_FOLDER_PATH}"

                        def chartFile = sh(
                            script: 'test -f Chart.yaml && echo Chart.yaml || (test -f Chart.yml && echo Chart.yml)',
                            returnStdout: true
                        ).trim()

                        if (!chartFile) {
                            error("‚ùå No Chart.yaml or Chart.yml found in workspace")
                        }

                        echo "üìÑ Using chart file: ${chartFile}"
                        env.APP_NAME    = sh(script: "yq eval -r '.name' ${chartFile}", returnStdout: true).trim()
                        env.APP_VERSION = sh(script: "yq eval -r '.version' ${chartFile}", returnStdout: true).trim()
                        env.TARGET_VERSION = "${env.APP_VERSION}-${env.BUILD_NUMBER}"

                        if (!env.APP_NAME || !env.APP_VERSION) {
                            error "‚ùå Chart file missing 'name' or 'version'"
                        }

                        echo "‚ÑπÔ∏è App Name: ${env.APP_NAME}"
                        echo "‚ÑπÔ∏è App Version: ${env.APP_VERSION}"
                        echo "‚ÑπÔ∏è Build Number: ${env.BUILD_NUMBER}"
                        echo "‚ÑπÔ∏è Target Version: ${env.TARGET_VERSION}"

                        echo "Updating the Deployment file"

                        def deploymentFile = sh(
                            script: "test -f ${env.APP_NAME}-app.yaml && echo ${env.APP_NAME}-app.yaml",
                            returnStdout: true
                        ).trim()

                        if (!deploymentFile) {
                            error("‚ùå No ${env.APP_NAME}-app.yaml found in workspace")
                        }
                        def cat_deployment_file=sh(script: "cat ${deploymentFile}", returnStdout: true).trim()
                        echo "Deployment File Before Update:- ${cat_deployment_file}"
                        try {
                            sh(
                                script: "yq -i '.spec.source.targetRevision = \"${env.TARGET_VERSION}\"' ${deploymentFile}",
                                returnStdout: true
                            ).trim()
                            echo "‚úÖ Deployment file updated: ${deploymentFile}"
                            def updatedContent = sh(
                            script: "cat ${deploymentFile}",
                            returnStdout: true).trim()
                            echo "üìÑ yq output: ${updatedContent}"
                        } catch (Exception e) {
                            error("üö´ Version upgrade error: ${e.message}")
                        }
                    }
                }
            }
        }

        stage('Package üì¶ Helm Chart') {
            when { expression { currentBuild.result == null || currentBuild.result == 'SUCCESS' } }
            steps {
                script {
                    echo "üì¶ Packaging Helm Chart"
                    echo "‚ÑπÔ∏è  App: ${env.APP_NAME} |   Target Version: ${env.TARGET_VERSION}"
                    echo "Updating the Chart.yaml with "
                    sh "helm package ${params.APP_FOLDER_PATH} --version ${env.TARGET_VERSION} --app-version ${env.APP_VERSION} -d /tmp"
                }
            }
        }

        stage('Push üì§ Helm Chart') {
            when { expression { currentBuild.result == null || currentBuild.result == 'SUCCESS' } }
            steps {
                script {
                    echo "üì§ Pushing Helm Chart"
                    // Example: sh "helm push /tmp/${env.APP_NAME}-${env.TARGET_VERSION}.tgz my-repo"
                }
            }
        }

        stage('Push üì§ to Git') {
            when { expression { currentBuild.result == null || currentBuild.result == 'SUCCESS' } }
            steps {
                withCredentials([usernamePassword(credentialsId: "GIT_CRED", usernameVariable: 'GIT_USER', passwordVariable: 'GIT_TOKEN')]) {
                    script {
                        sh """
                            git config user.email "sk.maifujalam@gmail.com"
                            git config user.name "${GIT_USER}"

                            git checkout ${params.GIT_BRANCH_NAME}

                            git add .

                            if ! git diff --cached --quiet; then
                              git commit -m "Edited with Jenkins pipeline: Build ${env.BUILD_NUMBER}"
                              git push https://${GIT_USER}:${GIT_TOKEN}@github.com/maifujalam/k8s_aws_lite.git ${params.GIT_BRANCH_NAME}
                            else
                              echo "‚úÖ No changes to commit"
                            fi
                        """
                    }
                }
            }
        }

        stage('Deploy üöÄ Argocd Application') {
            when { expression { currentBuild.result == null || currentBuild.result == 'SUCCESS' } }
            steps {
                script {
                    echo "üöÄ Deploying ArgoCD App"
                    sh "kubectl apply -f *-app.yaml"
                    echo "‚úÖ App Deployed. Sync in Argo CD if needed."
                }
            }
        }
    }

    post {
        always {
            echo "üèÅ Pipeline finished."
        }
        failure {
            echo "‚ùå Pipeline failed."
        }
        success {
            echo "‚úÖ Helm chart build & deployment successful."
        }
    }
}
